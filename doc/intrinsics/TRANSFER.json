{
  "keyword": "TRANSFER",
  "docstr": "`TRANSFER` — Transfer bit patterns\n\n### Description\nInterprets the bitwise representation of `SOURCE` in memory as if it\nis the representation of a variable or array of the same type and type\nparameters as `MOLD`.\n\n     \nThis is approximately equivalent to the C concept of <em>casting</em> one\ntype to another.\n\n\n\n\n### Syntax\n`RESULT = TRANSFER(SOURCE, MOLD[, SIZE])`\n\n\n### Arguments\n\n     \n | `SOURCE`  | Shall be a scalar or an array of any type. \n\n | `MOLD`    | Shall be a scalar or an array of any type. \n\n | `SIZE`    | (Optional) shall be a scalar of type\n`INTEGER`.\n\n\n\n\n\n\n### Return value\nThe result has the same type as `MOLD`, with the bit level\nrepresentation of `SOURCE`.  If `SIZE` is present, the result is\na one-dimensional array of length `SIZE`.  If `SIZE` is absent\nbut `MOLD` is an array (of any size or shape), the result is a one-\ndimensional array of the minimum length needed to contain the entirety\nof the bitwise representation of `SOURCE`.   If `SIZE` is absent\nand `MOLD` is a scalar, the result is a scalar.\n\n     \nIf the bitwise representation of the result is longer than that of\n`SOURCE`, then the leading bits of the result correspond to those of\n`SOURCE` and any trailing bits are filled arbitrarily.\n\n     \n\nWhen the resulting bit representation does not correspond to a valid\nrepresentation of a variable of the same type as `MOLD`, the results\nare undefined, and subsequent operations on the result cannot be\nguaranteed to produce sensible behavior.  For example, it is possible to\ncreate `LOGICAL` variables for which `VAR` and\n`.NOT.``VAR` both appear to be true.\n\n\n\n\n### Example\n```\n\n\nPROGRAM test_transfer\n\n  integer :: x = 2143289344\n\n  print *, transfer(x, 1.0)    ! prints \"NaN\" on i686\n\nEND PROGRAM\n\n```\n\n     \n\n### Standard\nFortran 95 and later\n\n\n\n### Class\nTransformational function\n\n\n"
}
