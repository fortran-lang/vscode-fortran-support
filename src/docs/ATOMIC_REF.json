{"keyword":"ATOMIC_REF","docstr":"`ATOMIC_REF` — Obtaining the value of a variable atomically\n\n### Description\n`ATOMIC_DEFINE(ATOM, VALUE)` atomically assigns the value of the\nvariable `ATOM` to `VALUE`. When `STAT` is present and the\ninvokation was successful, it is assigned the value 0. If it is present and the\ninvokation has failed, it is assigned a positive value; in particular, for a\ncoindexed `ATOM`, if the remote image has stopped, it is assigned the value\nof `ISO_FORTRAN_ENV`'s `STAT_STOPPED_IMAGE` and if the remote image\nhas failed, the value `STAT_FAILED_IMAGE`.\n\n\n\n### Syntax\n`CALL ATOMIC_REF(VALUE, ATOM [, STAT])`\n\n\n### Arguments\n\n     \n | `VALUE`   | Scalar of the same type as `ATOM`. If the kind\nis different, the value is converted to the kind of `ATOM`. \n\n | `ATOM`    | Scalar coarray or coindexed variable of either integer\ntype with `ATOMIC_INT_KIND` kind or logical type with\n`ATOMIC_LOGICAL_KIND` kind. \n\n | `STAT`    | (optional) Scalar default-kind integer variable.\n\n\n\n\n\n\n### Example\n\n     ```\n\n\nprogram atomic\n\n  use iso_fortran_env\n\n  logical(atomic_logical_kind) :: atom[*]\n\n  logical :: val\n\n  call atomic_ref (atom, .false.)\n\n  ! ...\n\n  call atomic_ref (atom, val)\n\n  if (val) then\n\n    print *, \"Obtained\"\n\n  end if\n\nend program atomic\n\n```\n\n\n\n### Standard\nFortran 2008 and later; with `STAT`, TS 18508 or later\n\n\n\n### Class\nAtomic subroutine\n\n\n\n### See also\n<a href=\"ATOMIC_005fDEFINE.html#ATOMIC_005fDEFINE\">ATOMIC_DEFINE</a>, <a href=\"ATOMIC_005fCAS.html#ATOMIC_005fCAS\">ATOMIC_CAS</a>, <a href=\"ISO_005fFORTRAN_005fENV.html#ISO_005fFORTRAN_005fENV\">ISO_FORTRAN_ENV</a>,\n<a href=\"ATOMIC_005fFETCH_005fADD.html#ATOMIC_005fFETCH_005fADD\">ATOMIC_FETCH_ADD</a>, <a href=\"ATOMIC_005fFETCH_005fAND.html#ATOMIC_005fFETCH_005fAND\">ATOMIC_FETCH_AND</a>, <a href=\"ATOMIC_005fFETCH_005fOR.html#ATOMIC_005fFETCH_005fOR\">ATOMIC_FETCH_OR</a>,\n<a href=\"ATOMIC_005fFETCH_005fXOR.html#ATOMIC_005fFETCH_005fXOR\">ATOMIC_FETCH_XOR</a>\n"}{"keyword":"ATOMIC_REF","docstr":"`ATOMIC_REF` — Obtaining the value of a variable atomically\n\n### Description\n`ATOMIC_DEFINE(ATOM, VALUE)` atomically assigns the value of the\nvariable `ATOM` to `VALUE`. When `STAT` is present and the\ninvokation was successful, it is assigned the value 0. If it is present and the\ninvokation has failed, it is assigned a positive value; in particular, for a\ncoindexed `ATOM`, if the remote image has stopped, it is assigned the value\nof `ISO_FORTRAN_ENV`'s `STAT_STOPPED_IMAGE` and if the remote image\nhas failed, the value `STAT_FAILED_IMAGE`.\n\n\n\n### Syntax\n`CALL ATOMIC_REF(VALUE, ATOM [, STAT])`\n\n\n### Arguments\n\n     \n | `VALUE`   | Scalar of the same type as `ATOM`. If the kind\nis different, the value is converted to the kind of `ATOM`. \n\n | `ATOM`    | Scalar coarray or coindexed variable of either integer\ntype with `ATOMIC_INT_KIND` kind or logical type with\n`ATOMIC_LOGICAL_KIND` kind. \n\n | `STAT`    | (optional) Scalar default-kind integer variable.\n\n\n\n\n\n\n### Example\n\n     ```\n\n\nprogram atomic\n\n  use iso_fortran_env\n\n  logical(atomic_logical_kind) :: atom[*]\n\n  logical :: val\n\n  call atomic_ref (atom, .false.)\n\n  ! ...\n\n  call atomic_ref (atom, val)\n\n  if (val) then\n\n    print *, \"Obtained\"\n\n  end if\n\nend program atomic\n\n```\n\n\n\n### Standard\nFortran 2008 and later; with `STAT`, TS 18508 or later\n\n\n\n### Class\nAtomic subroutine\n\n\n\n### See also\n<a href=\"ATOMIC_005fDEFINE.html#ATOMIC_005fDEFINE\">ATOMIC_DEFINE</a>, <a href=\"ATOMIC_005fCAS.html#ATOMIC_005fCAS\">ATOMIC_CAS</a>, <a href=\"ISO_005fFORTRAN_005fENV.html#ISO_005fFORTRAN_005fENV\">ISO_FORTRAN_ENV</a>,\n<a href=\"ATOMIC_005fFETCH_005fADD.html#ATOMIC_005fFETCH_005fADD\">ATOMIC_FETCH_ADD</a>, <a href=\"ATOMIC_005fFETCH_005fAND.html#ATOMIC_005fFETCH_005fAND\">ATOMIC_FETCH_AND</a>, <a href=\"ATOMIC_005fFETCH_005fOR.html#ATOMIC_005fFETCH_005fOR\">ATOMIC_FETCH_OR</a>,\n<a href=\"ATOMIC_005fFETCH_005fXOR.html#ATOMIC_005fFETCH_005fXOR\">ATOMIC_FETCH_XOR</a>\n"}