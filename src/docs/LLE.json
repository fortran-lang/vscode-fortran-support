{"keyword":"LLE","docstr":"`LLE` — Lexical less than or equal\n\n### Description\nDetermines whether one string is lexically less than or equal to another\nstring, where the two strings are interpreted as containing ASCII\ncharacter codes.  If the String A and String B are not the same length,\nthe shorter is compared as if spaces were appended to it to form a value\nthat has the same length as the longer.\n\n     \nIn general, the lexical comparison intrinsics `LGE`, `LGT`,\n`LLE`, and `LLT` differ from the corresponding intrinsic\noperators `.GE.`, `.GT.`, `.LE.`, and `.LT.`, in\nthat the latter use the processor's character ordering (which is not\nASCII on some targets), whereas the former always use the ASCII\nordering.\n\n\n\n\n### Syntax\n`RESULT = LLE(STRING_A, STRING_B)`\n\n\n### Arguments\n\n     \n type. \n\n | `STRING_B`  | Shall be of default `CHARACTER` type.\n\n\n\n\n\n\n### Return value\nReturns `.TRUE.` if `STRING_A &lt;= STRING_B`, and `.FALSE.`otherwise, based on the ASCII ordering.\n\n\n\n### Specific names\n\n     \n | Name                            | Argument           | Return type        | Standard\n\n | `LLE(STRING_A, STRING_B)`  | `CHARACTER`   | `LOGICAL`     | Fortran 77 and later\n\n\n\n\n\n\n### Standard\nFortran 77 and later\n\n\n\n### Class\nElemental function\n\n\n\n### See also\n<a href=\"LGE.html#LGE\">LGE</a>, <a href=\"LGT.html#LGT\">LGT</a>, <a href=\"LLT.html#LLT\">LLT</a>\n"}{"keyword":"LLE","docstr":"`LLE` — Lexical less than or equal\n\n### Description\nDetermines whether one string is lexically less than or equal to another\nstring, where the two strings are interpreted as containing ASCII\ncharacter codes.  If the String A and String B are not the same length,\nthe shorter is compared as if spaces were appended to it to form a value\nthat has the same length as the longer.\n\n     \nIn general, the lexical comparison intrinsics `LGE`, `LGT`,\n`LLE`, and `LLT` differ from the corresponding intrinsic\noperators `.GE.`, `.GT.`, `.LE.`, and `.LT.`, in\nthat the latter use the processor's character ordering (which is not\nASCII on some targets), whereas the former always use the ASCII\nordering.\n\n\n\n\n### Syntax\n`RESULT = LLE(STRING_A, STRING_B)`\n\n\n### Arguments\n\n     \n type. \n\n | `STRING_B`  | Shall be of default `CHARACTER` type.\n\n\n\n\n\n\n### Return value\nReturns `.TRUE.` if `STRING_A &lt;= STRING_B`, and `.FALSE.`otherwise, based on the ASCII ordering.\n\n\n\n### Specific names\n\n     \n | Name                            | Argument           | Return type        | Standard\n\n | `LLE(STRING_A, STRING_B)`  | `CHARACTER`   | `LOGICAL`     | Fortran 77 and later\n\n\n\n\n\n\n### Standard\nFortran 77 and later\n\n\n\n### Class\nElemental function\n\n\n\n### See also\n<a href=\"LGE.html#LGE\">LGE</a>, <a href=\"LGT.html#LGT\">LGT</a>, <a href=\"LLT.html#LLT\">LLT</a>\n"}