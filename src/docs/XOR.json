{"keyword":"XOR","docstr":"`XOR` — Bitwise logical exclusive OR\n\n### Description\nBitwise logical exclusive or.\n\n     \nThis intrinsic routine is provided for backwards compatibility with\nGNU Fortran 77.  For integer arguments, programmers should consider\nthe use of the <a href=\"IEOR.html#IEOR\">IEOR</a> intrinsic and for logical arguments the\n`.NEQV.` operator, which are both defined by the Fortran standard.\n\n\n\n\n### Syntax\n`RESULT = XOR(I, J)`\n\n\n### Arguments\n\n     \n\ntype or a scalar `LOGICAL` type. \n\n | `J`  | The type shall be the same as the type of `I`.\n\n\n\n\n\n\n### Return value\nThe return type is either a scalar `INTEGER` or a scalar\n`LOGICAL`.  If the kind type parameters differ, then the\nsmaller kind type is implicitly converted to larger kind, and the\nreturn has the larger kind.\n\n\n\n### Example\n\n     ```\n\n\nPROGRAM test_xor\n\n  LOGICAL :: T = .TRUE., F = .FALSE.\n\n  INTEGER :: a, b\n\n  DATA a / Z'F' /, b / Z'3' /\n\n\n  WRITE (*,*) XOR(T, T), XOR(T, F), XOR(F, T), XOR(F, F)\n\n  WRITE (*,*) XOR(a, b)\n\nEND PROGRAM\n\n```\n\n\n\n### Standard\nGNU extension\n\n\n\n### Class\nFunction\n\n\n\n### See also\nFortran 95 elemental function: <a href=\"IEOR.html#IEOR\">IEOR</a>\n"}