{"keyword":"PACK","docstr":"`PACK` — Pack an array into an array of rank one\n\n### Description\nStores the elements of `ARRAY` in an array of rank one.\n\n     \nThe beginning of the resulting array is made up of elements whose `MASK`\nequals `TRUE`. Afterwards, positions are filled with elements taken from\n`VECTOR`.\n\n\n\n\n### Syntax\n`RESULT = PACK(ARRAY, MASK[,VECTOR])`\n\n\n### Arguments\n\n     \n | `ARRAY`   | Shall be an array of any type. \n\n | `MASK`    | Shall be an array of type `LOGICAL` and\nof the same size as `ARRAY`. Alternatively, it may be a `LOGICAL`scalar. \n\n | `VECTOR`  | (Optional) shall be an array of the same type\nas `ARRAY` and of rank one. If present, the number of elements in\n`VECTOR` shall be equal to or greater than the number of true elements\nin `MASK`. If `MASK` is scalar, the number of elements in\n`VECTOR` shall be equal to or greater than the number of elements in\n`ARRAY`.\n\n\n\n\n\n\n### Return value\nThe result is an array of rank one and the same type as that of `ARRAY`. \nIf `VECTOR` is present, the result size is that of `VECTOR`, the\nnumber of `TRUE` values in `MASK` otherwise.\n\n\n\n### Example\nGathering nonzero elements from an array:\n     ```\n\n\nPROGRAM test_pack_1\n\n  INTEGER :: m(6)\n\n  m = (/ 1, 0, 0, 0, 5, 0 /)\n\n  WRITE(*, FMT=\"(6(I0, ' '))\") pack(m, m /= 0)  ! \"1 5\"\n\nEND PROGRAM\n\n```\n\n     \nGathering nonzero elements from an array and appending elements from `VECTOR`:\n     \n<pre class=\"smallexample\">          PROGRAM test_pack_2\n            INTEGER :: m(4)\n            m = (/ 1, 0, 0, 2 /)\n            WRITE(*, FMT=\"(4(I0, ' '))\") pack(m, m /= 0, (/ 0, 0, 3, 4 /))  ! \"1 2 3 4\"\n          END PROGRAM\n</pre>\n\n\n### Standard\nFortran 95 and later\n\n\n\n### Class\nTransformational function\n\n\n\n### See also\n<a href=\"UNPACK.html#UNPACK\">UNPACK</a>\n"}