{"keyword":"FLUSH","docstr":"`FLUSH` â€” Flush I/O unit(s)\n\n### Description\nFlushes Fortran unit(s) currently open for output. Without the optional\nargument, all units are flushed, otherwise just the unit specified.\n\n\n\n### Syntax\n`CALL FLUSH(UNIT)`\n\n\n### Arguments\n\n     \n.\n\n\n\n\n\n\n### Notes\nBeginning with the Fortran 2003 standard, there is a `FLUSH`statement that should be preferred over the `FLUSH` intrinsic.\n\n     \nThe `FLUSH` intrinsic and the Fortran 2003 `FLUSH` statement\nhave identical effect: they flush the runtime library's I/O buffer so\nthat the data becomes visible to other processes. This does not guarantee\nthat the data is committed to disk.\n\n     \n\nOn POSIX systems, you can request that all data is transferred  to  the\nstorage device by calling the `fsync` function, with the POSIX file\ndescriptor of the I/O unit as argument (retrieved with GNU intrinsic\n`FNUM`). The following example shows how:\n\n     \n<pre class=\"smallexample\">            ! Declare the interface for POSIX fsync function\n            interface\n              function fsync (fd) bind(c,name=\"fsync\")\n              use iso_c_binding, only: c_int\n                integer(c_int), value :: fd\n                integer(c_int) :: fsync\n              end function fsync\n            end interface\n          \n            ! Variable declaration\n            integer :: ret\n          \n            ! Opening unit 10\n            open (10,file=\"foo\")\n          \n            ! ...\n            ! Perform I/O on unit 10\n            ! ...\n          \n            ! Flush and sync\n            flush(10)\n            ret = fsync(fnum(10))\n          \n            ! Handle possible error\n            if (ret /= 0) stop \"Error calling FSYNC\"\n</pre>\n     \n\n### Standard\nGNU extension\n\n\n\n### Class\nSubroutine\n\n\n"}