{
  "keyword": "COUNT",
  "docstr": "`COUNT` — Count function\n\n### Description\n\nCounts the number of `.TRUE.` elements in a logical `MASK`,\nor, if the `DIM` argument is supplied, counts the number of\nelements along each row of the array in the `DIM` direction. \nIf the array has zero size, or all of the elements of `MASK` are\n`.FALSE.`, then the result is `0`.\n\n\n\n### Syntax\n`RESULT = COUNT(MASK [, DIM, KIND])`\n\n\n### Arguments\n\n     \n. \n\n | `DIM`   | (Optional) The type shall be `INTEGER`. \n\n | `KIND`  | (Optional) An `INTEGER` initialization\nexpression indicating the kind parameter of the result.\n\n\n\n\n\n\n### Return value\nThe return value is of type `INTEGER` and of kind `KIND`. If\n`KIND` is absent, the return value is of default integer kind. \nIf `DIM` is present, the result is an array with a rank one less\nthan the rank of `ARRAY`, and a size corresponding to the shape\nof `ARRAY` with the `DIM` dimension removed.\n\n\n\n### Example\n```\n\n\nprogram test_count\n\n    integer, dimension(2,3) :: a, b\n\n    logical, dimension(2,3) :: mask\n\n    a = reshape( (/ 1, 2, 3, 4, 5, 6 /), (/ 2, 3 /))\n\n    b = reshape( (/ 0, 7, 3, 4, 5, 8 /), (/ 2, 3 /))\n\n    print '(3i3)', a(1,:)\n\n    print '(3i3)', a(2,:)\n\n    print *\n\n    print '(3i3)', b(1,:)\n\n    print '(3i3)', b(2,:)\n\n    print *\n\n    mask = a.ne.b\n\n    print '(3l3)', mask(1,:)\n\n    print '(3l3)', mask(2,:)\n\n    print *\n\n    print '(3i3)', count(mask)\n\n    print *\n\n    print '(3i3)', count(mask, 1)\n\n    print *\n\n    print '(3i3)', count(mask, 2)\n\nend program test_count\n\n```\n\n     \n\n### Standard\nFortran 95 and later, with `KIND` argument Fortran 2003 and later\n\n\n\n### Class\nTransformational function\n\n\n"
}
