{
    "keyword":"AND",
    "docstr":"`AND` — Bitwise logical AND\n\n### Description\nBitwise logical `AND`.\n\n     \nThis intrinsic routine is provided for backwards compatibility with\nGNU Fortran 77.  For integer arguments, programmers should consider\nthe use of the <a href=\"IAND.html#IAND\">IAND</a> intrinsic defined by the Fortran standard.\n\n\n\n\n### Syntax\n`RESULT = AND(I, J)`\n\n\n### Arguments\n\n     \n\ntype or a scalar `LOGICAL` type. \n\n | `J`  | The type shall be the same as the type of `I`.\n\n\n\n\n\n\n### Return value\nThe return type is either a scalar `INTEGER` or a scalar\n`LOGICAL`.  If the kind type parameters differ, then the\nsmaller kind type is implicitly converted to larger kind, and the\nreturn has the larger kind.\n\n\n\n### Example\n```\n\n\nPROGRAM test_and\n\n  LOGICAL :: T = .TRUE., F = .FALSE.\n\n  INTEGER :: a, b\n\n  DATA a / Z'F' /, b / Z'3' /\n\n\n  WRITE (*,*) AND(T, T), AND(T, F), AND(F, T), AND(F, F)\n\n  WRITE (*,*) AND(a, b)\n\nEND PROGRAM\n\n```\n\n\n\n### Standard\nGNU extension\n\n\n\n### Class\nFunction\n\n\n\n### See also\nFortran 95 elemental function: <a href=\"IAND.html#IAND\">IAND</a>\n"
}