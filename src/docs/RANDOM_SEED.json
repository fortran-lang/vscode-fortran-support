{
  "keyword": "RANDOM_SEED",
  "docstr": "`RANDOM_SEED` — Initialize a pseudo-random number sequence\n\n### Description\nRestarts or queries the state of the pseudorandom number generator used by\n`RANDOM_NUMBER`.\n\n     \nIf `RANDOM_SEED` is called without arguments, it is initialized\nto a default state. The example below shows how to initialize the\nrandom seed with a varying seed in order to ensure a different random\nnumber sequence for each invocation of the program. Note that setting\nany of the seed values to zero should be avoided as it can result in\npoor quality random numbers being generated.\n\n\n\n\n### Syntax\n`CALL RANDOM_SEED([SIZE, PUT, GET])`\n\n\n### Arguments\n\n     \n | `SIZE`  | (Optional) Shall be a scalar and of type default\n`INTEGER`, with `INTENT(OUT)`. It specifies the minimum size\nof the arrays used with the `PUT` and `GET` arguments. \n\n | `PUT`   | (Optional) Shall be an array of type default\n`INTEGER` and rank one. It is `INTENT(IN)` and the size of\nthe array must be larger than or equal to the number returned by the\n`SIZE` argument. \n\n | `GET`   | (Optional) Shall be an array of type default\n`INTEGER` and rank one. It is `INTENT(OUT)` and the size\nof the array must be larger than or equal to the number returned by\nthe `SIZE` argument.\n\n\n\n\n\n\n### Example\n```\n\n\nsubroutine init_random_seed()\n\n  use iso_fortran_env, only: int64\n\n  implicit none\n\n  integer, allocatable :: seed(:)\n\n  integer :: i, n, un, istat, dt(8), pid\n\n  integer(int64) :: t\n\n\n  call random_seed(size = n)\n\n  allocate(seed(n))\n\n  ! First try if the OS provides a random number generator\n\n  open(newunit=un, file=\"/dev/urandom\", access=\"stream\", &amp;\n\n       form=\"unformatted\", action=\"read\", status=\"old\", iostat=istat)\n\n  if (istat == 0) then\n\n     read(un) seed\n\n     close(un)\n\n  else\n\n     ! Fallback to XOR:ing the current time and pid. The PID is\n\n     ! useful in case one launches multiple instances of the same\n\n     ! program in parallel.\n\n     call system_clock(t)\n\n     if (t == 0) then\n\n        call date_and_time(values=dt)\n\n        t = (dt(1) - 1970) * 365_int64 * 24 * 60 * 60 * 1000 &amp;\n\n             + dt(2) * 31_int64 * 24 * 60 * 60 * 1000 &amp;\n\n             + dt(3) * 24_int64 * 60 * 60 * 1000 &amp;\n\n             + dt(5) * 60 * 60 * 1000 &amp;\n\n             + dt(6) * 60 * 1000 + dt(7) * 1000 &amp;\n\n             + dt(8)\n\n     end if\n\n     pid = getpid()\n\n     t = ieor(t, int(pid, kind(t)))\n\n     do i = 1, n\n\n        seed(i) = lcg(t)\n\n     end do\n\n  end if\n\n  call random_seed(put=seed)\n\ncontains\n\n  ! This simple PRNG might not be good enough for real work, but is\n\n  ! sufficient for seeding a better PRNG.\n\n  function lcg(s)\n\n    integer :: lcg\n\n    integer(int64) :: s\n\n    if (s == 0) then\n\n       s = 104729\n\n    else\n\n       s = mod(s, 4294967296_int64)\n\n    end if\n\n    s = mod(s * 279470273_int64, 4294967291_int64)\n\n    lcg = int(mod(s, int(huge(0), int64)), kind(0))\n\n  end function lcg\n\nend subroutine init_random_seed\n\n```\n\n\n\n### Standard\nFortran 95 and later\n\n\n\n### Class\nSubroutine\n\n\n\n### See also\n<a href=\"RANDOM_005fNUMBER.html#RANDOM_005fNUMBER\">RANDOM_NUMBER</a>\n"
}
